---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.13.7
  kernelspec:
    display_name: venv
    language: python
    name: venv
---

```{python}
import os
import sys
```

```{python}
# %matplotlib inline

import matplotlib.pyplot as plt
```

```{python}
import cv2
import scipy
from scipy import ndimage as ndi
import numpy as np
import networkx as nx
```

```{python}
import napari
```

```{python}
from tqdm.auto import tqdm
```

```{python}
import ccdb
import astromorpho as astro
```
```{python}
from networx2napari import draw_edges, draw_nodes
```


 

```{python}
def weight_of_arr(a, b):
    dprod = np.einsum('...ij,...ij->...i', a, b)
    norm_a = np.linalg.norm(a, axis=-1)
    norm_b = np.linalg.norm(b, axis=-1)
    cos_dist = np.nan_to_num(dprod / ((norm_a * norm_b)), nan=0)
    cos_dist = 1 - cos_dist
    return np.abs(1 - cos_dist) * np.mean([norm_a, norm_b], axis=0)
```

```{python}
def calc_edges(arr1, arr2, index1, index2):
    weights = weight_of_arr(arr1, arr2)
    weight = weights.ravel()
    li = threshold_li(weight)
    idx1 = [tuple(i) for i in index1.reshape((-1, index1.shape[-1]))[weight>li]]
    idx2 = [tuple(i) for i in index2.reshape((-1, index2.shape[-1]))[weight>li]]
    return zip(idx1, idx2, 1 - weight[weight>li])
```

```{python}
def draw_nodes(pos, nodelist):
    return np.asarray([pos[n] for n in nodelist])
```

```{python}
def count_points_paths(paths):
    acc = {}
    for path in paths:
        for n in path:
            if n in acc.keys():
                acc[n] += 1
            else:
                acc[n] = 1
    return acc
```

Параметры для запуска

```{python tags=c("parameters")}
filename = '/home/levtg/astro-morpho/data/3wk-both1-grn-raw.pic'
verbose = True
sigma = 2

# Set false to start from console
HANDY = True
```

Считывание изображения

```{python}
stack, meta = ccdb.read_pic(filename)
dims = ccdb.get_axes(meta)
dims
```

```{python}
if len(dims):
    zoom = dims[0][0]/dims[-1][0]
else:
    zoom = 4
```

clahe

```{python}
clahe = cv2.createCLAHE(clipLimit =2.0, tileGridSize=(8,8))
```

```{python}
IMG_SHAPE = stack.shape
stack_flat = stack.reshape((IMG_SHAPE[0], -1))
img_flat = clahe.apply(stack_flat)
img = img_flat.reshape(IMG_SHAPE)
```

```{python}
plt.imshow(img.max(0), cmap='gray')
```

```{python}
img_noisy = ndi.zoom(img.astype(float),(1, zoom,zoom))
```

```{python}
plt.imshow(img_noisy.max(0), cmap='gray')
```

```{python}
napari.view_image(img_noisy)
```

Фильтрация изображения

```{python}
from skimage.filters import threshold_li
from skimage.morphology import remove_small_objects
```

```{python}
def filter_image(image, filter_func):
    threshold = filter_func(image)
    img_filt = np.where(image > threshold, image, 0)
    binary_clean = remove_small_objects(image >= threshold, 5, connectivity=3)
    return np.where(binary_clean, img_filt, 0)
```

```{python}
threshold = lambda x: 187
```

```{python}
img_clear = filter_image(img_noisy, threshold_li)
```

```{python}
final_image = img_clear
```

Матрица Гессе

```{python}
if HANDY:
    sigma = 4
```

```{python}
sato, Vf = astro.hessian.sato3d(final_image, sigma, hessian_variant='gradient_of_smoothed', return_vectors=True)
```

```{python}
Vfx = Vf[...,0][...,::-1]
V = Vfx[..., 0]
U = Vfx[..., 1]
C = Vfx[..., 2]
```

```{python}
lengths = astro.enh.percentile_rescale(sato)**0.5
```

```{python}
vectors = np.stack((U*lengths, V*lengths, C*lengths), axis=3)
```

Построение графа

```{python}
crops = [((slice(1, None)), (slice(None, -1))),
         ((slice(1, None), slice(1, None), slice(1, None)), (slice(None, -1), slice(None, -1), slice(None, -1))),
         ((slice(1, None), slice(None, -1), slice(None, -1)), (slice(None, -1), slice(1, None), slice(1, None))),
         ((slice(1, None), slice(1, None)), (slice(None, -1), slice(None, -1))),
         ((slice(1, None), slice(None, -1)), (slice(None, -1), slice(1, None))),
         ((slice(1, None), slice(1, None), slice(None, -1)), (slice(None, -1), slice(None, -1), slice(1, None))),
         ((slice(1, None), slice(None, -1), slice(1, None)), (slice(None, -1), slice(1, None), slice(None, -1))),
         ((slice(1, None), slice(None), slice(None, -1)), (slice(None, -1), slice(None), slice(1, None))),
         ((slice(1, None), slice(None), slice(1, None)), (slice(None, -1), slice(None), slice(None, -1))),
         ((slice(None), slice(1, None), slice(1, None)), (slice(None), slice(None, -1), slice(None, -1))),
         ((slice(None), slice(1, None)), (slice(None), slice(None, -1))),
         ((slice(None), slice(1, None), slice(None, -1)), (slice(None), slice(None, -1), slice(1, None))),
         ((slice(None), slice(None), slice(None, -1)), (slice(None), slice(None), slice(1, None)))]
```

```{python}
i, j, k = np.indices(vectors.shape[:-1])
idx = np.stack((i,j,k), axis=3)
```

```{python}
G3 = nx.Graph()
nodes3 = {}
```

```{python}
for crop, acrop in tqdm(crops):
    G3.add_weighted_edges_from(calc_edges(vectors[crop], vectors[acrop], idx[crop], idx[acrop]))
```

```{python}
nodes3 = {n:n for n in G3.nodes()}
```

Выделение сомы

```{python}
from skimage.morphology import erosion, dilation
```

```{python}
to_erose = final_image[:]
```

```{python}
for i in range(6):
    to_erose = erosion(to_erose)
```

```{python}
eroded = remove_small_objects(to_erose > 0, 5, connectivity=3)
```

```{python}
soma_mask = np.where(dilation(eroded), True, False)
```

```{python}
if verbose:
    w = napari.view_image(final_image)
    w.add_image(soma_mask, blending='additive', colormap='cyan')
```

```{python}
soma = [tuple(i) for i in idx[soma_mask]]
```

Определение центра

```{python}
import itertools as itt
```

```{python}
def percentile_rescale(arr, plow=1, phigh=99.5):
    low, high = np.percentile(arr, (plow, phigh))
    if low == high:
        return np.zeros_like(arr)
    else:
        return np.clip((arr-low)/(high-low), 0, 1)
```

```{python}
zstack = final_image[:]
```

```{python}
# %time X = np.array(list(itt.product(*map(range, zstack.shape))))
```

```{python}
weights_s = percentile_rescale(np.ravel(ndi.gaussian_filter(zstack,5))**2,plow=99.5,phigh=99.99)
```

```{python}
center = tuple(map(int, np.sum(X*weights_s[:,None],axis=0)/np.sum(weights_s)))
center
```

Добавление точек сомы в граф

```{python}
G = nx.complete_graph(soma)
```

```{python}
nx.set_edge_attributes(G, 0.7, name='weight')
```

```{python}
for p1, p2, weight in G.edges(data=True):
    try:
        old_weight = G3.get_edge_data(p1, p2)['weight']
    except:
        old_weight = 1
    G3.add_edge(p1, p2, weight=min(weight['weight'], old_weight))
```

```{python}
nodes3 = {n:n for n in G3.nodes()}
```

Расчет путей

```{python}
# %time paths_dict = nx.single_source_dijkstra_path(G3, center)
```

```{python}
paths = list(paths_dict.values())
```

```{python}
np.save('{}_sigma{}_paths_all'.format(os.path.basename(filename), sigma), np.array(paths, dtype=object))
```

Расчет встречаемости

```{python}
points = count_points_paths(paths)
```

```{python}
np.save('{}_sigma{}_points_count'.format(os.path.basename(filename), sigma), np.array(points, dtype=object))
```

```{python}
if verbose:
    w.add_points(draw_nodes(nodes3, points), size=1, edge_color='transparent', face_color='b', name='count')
```

```{python}
count_1 = []
for path in paths:
    count = 0
    for n in path:
        if points[n] == 1:
            count += 1
    count_1.append(count)
```

```{python}
plt.hist(count_1)
plt.show()
```

```{python}
to_del = []
for point, count in points.items():
    if count == 1:
        to_del.append(point)
```

Фильтрация точек по встречаемости

```{python}
from copy import copy
points_count = copy(points)
```

```{python}
for point in to_del:
    del points_count[point]
```

```{python}
sorted(points_count.values())[-20:]
```

```{python}
del points_count[center]
```

```{python}
if verbose:
    w.add_points(draw_nodes(nodes3, points_count), size=1, edge_color='transparent', face_color='r', name='count')
```

```{python}
qstack = np.zeros(vectors.shape[:-1])
for loc, val in points_count.items():
    qstack[loc] = np.log(val)
```

```{python}
if verbose:
    w.add_image(qstack)
```

```{python}
p = np.asarray(list(points_count.keys()))
```

```{python}
vals = np.asarray(list(points_count.values()))
```

```{python}
plt.figure(figsize=(16,8))
plt.hist(np.log(vals[vals>1]), bins=500)
#plt.xlim(-10, 100)
plt.axvline(np.mean(np.log(vals)), color='cyan', ls='--', label='th.mean')
plt.axvline(threshold_li(np.log(vals)), color='tomato', ls='--', label='th.Li')
plt.axvline(np.log(np.mean(vals)), color='b', ls='--', label='th.log_mean')
plt.legend()
plt.show()
```

```{python}
plt.figure(figsize=(16,8))
plt.hist(vals[vals>1], bins=500)
#plt.xlim(-10, 100)
plt.axvline(np.mean(vals), color='b', ls='--', label='th.mean')
plt.axvline(threshold_li(vals), color='tomato', ls='--', label='th.Li')
plt.axvline(np.exp(np.mean(np.log(vals))), color='cyan', ls='--', label='th.log_mean')
plt.legend()
plt.show()
```

```{python}
points_mean = [k for k, v in points_count.items() if v > np.mean(vals)]
points_li = [k for k, v in points_count.items() if v > threshold_li(vals)]
# points_log_mean = [k for k, v in points_count.items() if np.log(v) > np.mean(np.log(vals))]
# points_log_li = [k for k, v in points_count.items() if np.log(v) > threshold_li(np.log(vals))]
```

```{python}
if verbose:
    w.add_points(draw_nodes(nodes3, points_mean), size=1, edge_color='transparent', face_color='m', name='filt mean')
    w.add_points(draw_nodes(nodes3, points_li), size=1, edge_color='transparent', face_color='g', name='filt li')
```

# Tree creation

```{python}
Gsub = G3.subgraph(points_mean)
nodes_sub = {n:n for n in Gsub.nodes()}
```

```{python}
props = {'weight': 1 - np.array([edgedata["weight"] for _, _, edgedata in Gsub.edges(data=True)])}
```

```{python}
w.add_shapes(draw_edges(nodes_sub, list(Gsub.edges())), shape_type='path', edge_color='weight', edge_width=0.1, edge_colormap='inferno', properties=props)
```

```{python}

```

```{python}

```
