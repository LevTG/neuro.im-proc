---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.13.7
  kernelspec:
    display_name: venv
    language: python
    name: venv
---

<!-- #region toc=true -->
<h1>Table of Contents<span class="tocSkip"></span></h1>
<div class="toc"><ul class="toc-item"><li><span><a href="#Параметры-для-запуска" data-toc-modified-id="Параметры-для-запуска-1">Параметры для запуска</a></span></li><li><span><a href="#Считывание-изображения" data-toc-modified-id="Считывание-изображения-2">Считывание изображения</a></span></li><li><span><a href="#Фильтрация-изображения" data-toc-modified-id="Фильтрация-изображения-3">Фильтрация изображения</a></span></li><li><span><a href="#Выделение-сомы" data-toc-modified-id="Выделение-сомы-4">Выделение сомы</a></span></li><li><span><a href="#Определение-центра" data-toc-modified-id="Определение-центра-5">Определение центра</a></span></li><li><span><a href="#Выделение-толстых-отростков" data-toc-modified-id="Выделение-толстых-отростков-6">Выделение толстых отростков</a></span></li><li><span><a href="#Матрица-Гессе" data-toc-modified-id="Матрица-Гессе-7">Матрица Гессе</a></span></li><li><span><a href="#Построение-графа" data-toc-modified-id="Построение-графа-8">Построение графа</a></span><ul class="toc-item"><li><span><a href="#Добавление-точек-сомы-в-граф" data-toc-modified-id="Добавление-точек-сомы-в-граф-8.1">Добавление точек сомы в граф</a></span></li></ul></li><li><span><a href="#Расчет-путей" data-toc-modified-id="Расчет-путей-9">Расчет путей</a></span></li><li><span><a href="#Расчет-встречаемости" data-toc-modified-id="Расчет-встречаемости-10">Расчет встречаемости</a></span></li><li><span><a href="#Фильтрация-точек-по-встречаемости" data-toc-modified-id="Фильтрация-точек-по-встречаемости-11">Фильтрация точек по встречаемости</a></span></li><li><span><a href="#Выделение-тонких-веток" data-toc-modified-id="Выделение-тонких-веток-12">Выделение тонких веток</a></span></li><li><span><a href="#Объединение" data-toc-modified-id="Объединение-13">Объединение</a></span><ul class="toc-item"><li><span><a href="#Выделение-крайних-точек" data-toc-modified-id="Выделение-крайних-точек-13.1">Выделение крайних точек</a></span></li><li><span><a href="#Ближайшие-точки-скелета" data-toc-modified-id="Ближайшие-точки-скелета-13.2">Ближайшие точки скелета</a></span></li><li><span><a href="#Добавление-соединений" data-toc-modified-id="Добавление-соединений-13.3">Добавление соединений</a></span></li></ul></li><li><span><a href="#Многомасштабный-гессиан" data-toc-modified-id="Многомасштабный-гессиан-14">Многомасштабный гессиан</a></span></li></ul></div>
<!-- #endregion -->

```{python}
import os
import sys
```

```{python}
# %matplotlib inline

import matplotlib.pyplot as plt
```

```{python}
import cv2
import scipy
from scipy import ndimage as ndi
import numpy as np
import networkx as nx
```

```{python}
import napari
```

```{python}
from tqdm.auto import tqdm
```

```{python}
import ccdb
import astromorpho as astro
```
```{python}
from networx2napari import draw_edges, draw_nodes
```


 

```{python}
def weight_of_arr(a, b):
    dprod = np.einsum('...ij,...ij->...i', a, b)
    norm_a = np.linalg.norm(a, axis=-1)
    norm_b = np.linalg.norm(b, axis=-1)
    cos_dist = np.nan_to_num(dprod / ((norm_a * norm_b)), nan=0)
    cos_dist = 1 - cos_dist
    return np.abs(1 - cos_dist) * np.mean([norm_a, norm_b], axis=0)
```

```{python}
def calc_edges(arr1, arr2, index1, index2):
    weights = weight_of_arr(arr1, arr2)
    weight = weights.ravel()
    li = threshold_li(weight)
    idx1 = [tuple(i) for i in index1.reshape((-1, index1.shape[-1]))[weight>li]]
    idx2 = [tuple(i) for i in index2.reshape((-1, index2.shape[-1]))[weight>li]]
    return zip(idx1, idx2, 1 - weight[weight>li])
```

```{python}
def count_points_paths(paths):
    acc = {}
    for path in paths:
        for n in path:
            if n in acc.keys():
                acc[n] += 1
            else:
                acc[n] = 1
    return acc
```

# Параметры для запуска

```{python tags=c("parameters")}
filename = '/home/levtg/astro-morpho/data/3wk-both1-grn-raw.pic'
verbose = True
sigma = 2

# Set false to start from console
HANDY = True

# Set true to save output
OUT = False
```

# Считывание изображения

```{python}
if HANDY:
    filename = '/home/levtg/astro-morpho/data/3wk-ly10-raw.pic'
```

```{python}
stack, meta = ccdb.read_pic(filename)
dims = ccdb.get_axes(meta)
dims
```

```{python}
if len(dims):
    zoom = dims[0][0]/dims[-1][0]
else:
    zoom = 4
```

clahe

```{python}
clahe = cv2.createCLAHE(clipLimit =2.0, tileGridSize=(8,8))
```

```{python}
IMG_SHAPE = stack.shape
stack_flat = stack.reshape((IMG_SHAPE[0], -1))
img_flat = clahe.apply(stack_flat)
img = img_flat.reshape(IMG_SHAPE)
```

```{python}
plt.imshow(img.max(0), cmap='gray')
```

```{python}
img_noisy = ndi.zoom(img.astype(float),(1, zoom,zoom))
```

```{python}
plt.imshow(img_noisy.max(0), cmap='gray')
```

```{python}
# napari.view_image(img_noisy)
```

# Фильтрация изображения

```{python}
from skimage.filters import threshold_li, threshold_minimum
from skimage.morphology import remove_small_objects
```

```{python}
def filter_image(image, filter_func):
    threshold = filter_func(image)
    img_filt = np.where(image > threshold, image, 0)
    binary_clean = remove_small_objects(image >= threshold, 5, connectivity=3)
    return np.where(binary_clean, img_filt, 0)
```

```{python}
threshold = lambda x: 187
```

```{python}
img_clear = filter_image(img_noisy, threshold_li)
if HANDY:
    pass
#     img_clear = filter_image(img_noisy, threshold_minimum)
```

```{python}
final_image = img_clear
```

```{python}
w = napari.view_image(final_image, colormap='magenta')
```

# Выделение сомы

```{python}
from skimage.morphology import erosion, dilation
```

```{python}
to_erose = final_image[:]
```

```{python}
for i in range(6):
    to_erose = erosion(to_erose)
```

```{python}
eroded = remove_small_objects(to_erose > 0, 5, connectivity=3)
```

```{python}
soma_mask = np.where(dilation(eroded), True, False)
```

```{python}
if verbose:
    w.add_image(soma_mask, blending='additive', colormap='cyan')
```

```{python}
i, j, k = np.indices(final_image.shape)
idx = np.stack((i,j,k), axis=3)
```

```{python}
soma = [tuple(i) for i in idx[soma_mask]]
```

# Определение центра

```{python}
import itertools as itt
```

```{python}
def percentile_rescale(arr, plow=1, phigh=99.5):
    low, high = np.percentile(arr, (plow, phigh))
    if low == high:
        return np.zeros_like(arr)
    else:
        return np.clip((arr-low)/(high-low), 0, 1)
```

```{python}
zstack = final_image[:]
```

```{python}
# %time X = np.array(list(itt.product(*map(range, zstack.shape))))
```

```{python}
weights_s = percentile_rescale(np.ravel(ndi.gaussian_filter(zstack,5))**2,plow=99.5,phigh=99.99)
```

```{python}
center = tuple(map(int, np.sum(X*weights_s[:,None],axis=0)/np.sum(weights_s)))
center
```

# Выделение толстых отростков

```{python}
branches = filter_image(img_noisy, threshold_minimum)
img_branch = branches/branches.max()
```

```{python}
from skimage.morphology import skeletonize, flood
```

```{python}
flood_mask = flood(img_branch > 0, center)
if verbose:
    w.add_image(flood_mask, colormap='red', opacity=0.5)
```

```{python}
img = np.where(flood_mask, img_branch, 0)
skeleton = skeletonize(img)
if verbose:
    w.add_image(skeleton, blending='additive', colormap='cyan')
```

```{python}
w_branch_mask = skeleton == 255
```

TEST AREA START

```{python}
def localize_graph_points(G, point_loc, nodes=None, dist=1):
    if nodes is None:
        nodes = G.nodes()
    node_coords = np.array(nodes.keys())
    node_dists = np.linalg.norm(point_loc-node_coords, axis=-1)
    suit_points = [tuple(n) for n in node_coords[node_dists < dist]]
    return suit_points
```

```{python}
def set_graph_area(G, area_mask, out=True, set_name=None):
    coords = np.array(G.nodes())
    node_check = area_mask[coords[:,0], coords[:,1], coords[:,2]]
    selected_nodes = [tuple(n) for n in coords[node_check]]
   
    if set_name is not None:
        nx.set_node_attributes(G, {tuple(n): {'area':set_name} for n in coords[node_check]})
                
    if out:
        return selected_nodes
```

Нужна функция для выделения сабграфа (библиотечная делает ридонли). Функция ниже из доков. Требует осмысления и доработки.

```{python}
def create_subgraph(G, nodes):
    # Create a subgraph SG based on a (possibly multigraph) G
    SG = G.__class__()
    SG.add_nodes_from((n, G.nodes[n]) for n in largest_wcc)
    if SG.is_multigraph():
        SG.add_edges_from((n, nbr, key, d)
            for n, nbrs in G.adj.items() if n in largest_wcc
            for nbr, keydict in nbrs.items() if nbr in largest_wcc
            for key, d in keydict.items())
    else:
        SG.add_edges_from((n, nbr, d)
            for n, nbrs in G.adj.items() if n in largest_wcc
            for nbr, d in nbrs.items() if nbr in largest_wcc)
    SG.graph.update(G.graph)
    return SG
```

```{python}
# nodes= G3.nodes()
# c = np.array(nodes)
# sc = soma_mask[c[:,0], c[:,1], c[:,2]]
# soma_nodes = [tuple(n) for n in c[sc]]
# G3.remove_nodes_from(soma_nodes)

```

```{python}
# Gsub2 = G3.subgraph(points_mean)
# new_nodes = {n:n for n in Gsub2.nodes()}
```

```{python}
# Gsub2 = G3.subgraph(soma_nodes)
# new_nodes = {n:n for n in Gsub2.nodes()}
# props = {'weight': 1 - np.array([edgedata["weight"] for _, _, edgedata in Gsub2.edges(data=True)])}
# w.add_shapes(draw_edges(new_nodes, list(Gsub2.edges())), 
#              shape_type='path', 
#              edge_color='weight', 
#              edge_width=0.1, 
#              edge_colormap='inferno', 
#              properties=props)
```

TEST AREA END


# Матрица Гессе

```{python}
if HANDY:
    sigma = 1.5
```

```{python}
sato, Vf = astro.hessian.sato3d(final_image, sigma, hessian_variant='gradient_of_smoothed', return_vectors=True)
```

```{python}
Vfx = Vf[...,0][...,::-1]
V = Vfx[..., 0]
U = Vfx[..., 1]
C = Vfx[..., 2]
```

```{python}
lengths = astro.enh.percentile_rescale(sato)**0.5
```

```{python}
vectors = np.stack((U*lengths, V*lengths, C*lengths), axis=3)
```

# Построение графа

```{python}
crops = [((slice(1, None)), (slice(None, -1))),
         ((slice(1, None), slice(1, None), slice(1, None)), (slice(None, -1), slice(None, -1), slice(None, -1))),
         ((slice(1, None), slice(None, -1), slice(None, -1)), (slice(None, -1), slice(1, None), slice(1, None))),
         ((slice(1, None), slice(1, None)), (slice(None, -1), slice(None, -1))),
         ((slice(1, None), slice(None, -1)), (slice(None, -1), slice(1, None))),
         ((slice(1, None), slice(1, None), slice(None, -1)), (slice(None, -1), slice(None, -1), slice(1, None))),
         ((slice(1, None), slice(None, -1), slice(1, None)), (slice(None, -1), slice(1, None), slice(None, -1))),
         ((slice(1, None), slice(None), slice(None, -1)), (slice(None, -1), slice(None), slice(1, None))),
         ((slice(1, None), slice(None), slice(1, None)), (slice(None, -1), slice(None), slice(None, -1))),
         ((slice(None), slice(1, None), slice(1, None)), (slice(None), slice(None, -1), slice(None, -1))),
         ((slice(None), slice(1, None)), (slice(None), slice(None, -1))),
         ((slice(None), slice(1, None), slice(None, -1)), (slice(None), slice(None, -1), slice(1, None))),
         ((slice(None), slice(None), slice(None, -1)), (slice(None), slice(None), slice(1, None)))]
```

```{python}
G3 = nx.Graph()
nodes3 = {}
```

```{python}
for crop, acrop in tqdm(crops):
     G3.add_weighted_edges_from(calc_edges(vectors[crop], vectors[acrop], idx[crop], idx[acrop]))
```

## Добавление точек сомы в граф

```{python}
def get_mask_vals(idxs, mask):
    idx_mask = mask[idxs[:,0], idxs[:,1], idxs[:,2]]
    return idxs[idx_mask]
```

```{python}
def get_edges(mask, index1, index2, weight):
    idx1 = [tuple(i) for i in get_mask_vals(index1.reshape((-1, index1.shape[-1])), mask)]
    idx2 = [tuple(i) for i in get_mask_vals(index2.reshape((-1, index2.shape[-1])), mask)]
    return zip(idx1, idx2, np.full(len(idx1), weight))
```

```{python}
Gsoma = nx.Graph()
```

```{python}
for crop, acrop in tqdm(crops):
    Gsoma.add_weighted_edges_from(get_edges(soma_mask, idx[crop], idx[acrop], 0.7))
```

```{python}
nx.set_edge_attributes(G, 0.7, name='weight')
# nx.set_edge_attributes(G, 'soma', name='area')
```

```{python}
for p1, p2, weight in Gsoma.edges(data=True):
    try:
        old_weight = G3.get_edge_data(p1, p2)['weight']
    except:
        old_weight = 1
    G3.add_edge(p1, p2, weight=min(weight['weight'], old_weight))
```

```{python}
nodes3 = {n:n for n in G3.nodes()}
```

# Расчет путей

```{python}
# %time paths_dict = nx.single_source_dijkstra_path(G3, center)
```

```{python}
paths = list(paths_dict.values())
```

```{python}
if OUT:
    np.save('{}_sigma{}_paths_all'.format(os.path.basename(filename), sigma), np.array(paths, dtype=object))
```

# Расчет встречаемости

```{python}
points = count_points_paths(paths)
```

```{python}
if OUT:
    np.save('{}_sigma{}_points_count'.format(os.path.basename(filename), sigma), np.array(points, dtype=object))
```

```{python}
if verbose:
    w.add_points(draw_nodes(nodes3, points), size=1, edge_color='transparent', face_color='b', name='count')
```

```{python}
count_1 = []
for path in paths:
    count = 0
    for n in path:
        if points[n] == 1:
            count += 1
    count_1.append(count)
```

```{python}
plt.hist(count_1)
plt.show()
```

```{python}
to_del = []
for point, count in points.items():
    if count == 1:
        to_del.append(point)
```

# Фильтрация точек по встречаемости

```{python}
from copy import copy
points_count = copy(points)
```

```{python}
for point in to_del:
    del points_count[point]
```

```{python}
sorted(points_count.values())[-20:]
```

```{python}
del points_count[center]
```

```{python}
if verbose:
    w.add_points(draw_nodes(nodes3, points_count), size=1, edge_color='transparent', face_color='r', name='count')
```

```{python}
qstack = np.zeros(vectors.shape[:-1])
for loc, val in points_count.items():
    qstack[loc] = np.log(val)
```

```{python}
if verbose:
    w.add_image(qstack)
```

```{python}
p = np.asarray(list(points_count.keys()))
```

```{python}
vals = np.asarray(list(points_count.values()))
```

```{python}
plt.figure(figsize=(16,8))
plt.hist(np.log(vals[vals>1]), bins=500)
#plt.xlim(-10, 100)
plt.axvline(np.mean(np.log(vals)), color='cyan', ls='--', label='th.mean')
plt.axvline(threshold_li(np.log(vals)), color='tomato', ls='--', label='th.Li')
plt.axvline(np.log(np.mean(vals)), color='b', ls='--', label='th.log_mean')
plt.legend()
plt.show()
```

```{python}
plt.figure(figsize=(16,8))
plt.hist(vals[vals>1], bins=500)
#plt.xlim(-10, 100)
plt.axvline(np.mean(vals), color='b', ls='--', label='th.mean')
plt.axvline(threshold_li(vals), color='tomato', ls='--', label='th.Li')
plt.axvline(np.exp(np.mean(np.log(vals))), color='cyan', ls='--', label='th.log_mean')
plt.legend()
plt.show()
```

```{python}
points_mean = [k for k, v in points_count.items() if v > np.mean(vals)]
thr_li = threshold_li(vals)
points_li = [k for k, v in points_count.items() if v > thr_li]
# points_log_mean = [k for k, v in points_count.items() if np.log(v) > np.mean(np.log(vals))]
# points_log_li = [k for k, v in points_count.items() if np.log(v) > threshold_li(np.log(vals))]
```

```{python}
if verbose:
    w.add_points(draw_nodes(nodes3, points_mean), size=1, edge_color='transparent', face_color='c', name='filt mean')
    w.add_points(draw_nodes(nodes3, points_li), size=1, edge_color='transparent', face_color='g', name='filt li')
```

# Выделение тонких веток

```{python}
Gsub = G3.subgraph(points_mean)
nodes_sub = {n:n for n in Gsub.nodes()}
```

```{python}
props = {'weight': 1 - np.array([edgedata["weight"] for _, _, edgedata in Gsub.edges(data=True)])}
```

```{python}
w.add_shapes(draw_edges(nodes_sub, list(Gsub.edges())), shape_type='path', edge_color='weight', edge_width=0.1, edge_colormap='inferno', properties=props)
```

```{python}
c = np.array(Gsub.nodes())
```

```{python}
graph_mask = np.full(final_image.shape, False)
graph_mask[c[:,0], c[:,1], c[:,2]] = True
```

```{python}
th_branch_mask = np.full(final_image.shape, False)
th_branch_mask[c[:,0], c[:,1], c[:,2]] = True
th_branch_mask[flood_mask] = False
```

```{python}
th_branch_mask = remove_small_objects(th_branch_mask, 5, connectivity=3)
```

# Объединение

```{python}
branch_mask = np.full(final_image.shape, False)
branch_mask[th_branch_mask] = True
branch_mask[w_branch_mask] = True
branch_mask[soma_mask] = True

if verbose:
    bm = napari.view_image(branch_mask)
    bm.add_image(final_image)
```

file:///home/levtg/astro-morpho/data/pictures_nb/join%20plan.jpg![image.png](attachment:image.png)


## Выделение крайних точек

```{python}
from skimage.morphology import cube
edge = dilation(flood_mask, cube(3)) ^ flood_mask
points = edge & th_branch_mask
```

```{python}
if verbose:
    bm.add_image(points)
```

```{python}
if verbose:
    bm.add_image(w_branch_mask)
    bm.add_image(th_branch_mask)
    bm.add_image(soma_mask)
    bm.add_image(flood_mask)
```

## Ближайшие точки скелета

```{python}
points_coords = idx[points]
skelet_coords = idx[w_branch_mask]
```

```{python}
points2connect = {}
for point in points_coords:
    point_dists = np.linalg.norm(point - skelet_coords, axis=-1)
    if len(points2connect.keys()) > 0:
        point_n_dists = np.linalg.norm(point - np.array(list(points2connect.keys())), axis=-1)
        if point_n_dists.min() < 1.5:
            continue
    if point_dists.min() > 1.5:
        coord = skelet_coords[point_dists.argmin()]
        points2connect[tuple(point)] = tuple(coord)
```

```{python}
print(points_coords.shape, len(points2connect.keys()))
```

## Добавление соединений

```{python}
# from networkx.algorithms.shortest_paths.weighted import multi_source_dijkstra
full_mask = branch_mask.copy()
for s, e in points2connect.items():
#     d, p = multi_source_dijkstra(G3, [tuple(n) for n in skelet_coords], s, 'weight')
    path = nx.shortest_path(G3, s, e, 'weight')
    path_coords = np.array(path)
    full_mask[path_coords[:,0], path_coords[:, 1], path_coords[:,2]] = True
```

```{python}
bm.add_image(full_mask)
```

# Многомасштабный гессиан

```{python}
from skimage.filters import ridges as skridges
```

![image.png](attachment:image.png)


https://content.iospress.com/download/bio-medical-materials-and-engineering/bme1149?id=bio-medical-materials-and-engineering%2Fbme1149


```{python}
def vesselness(img, sigma, alpha= 0.5, beta=0.5, cc=20):
    #H = skf.hessian_matrix(img,sigma)
    #Hl = skf.hessian_matrix_eigvals(H)
    Hl = skridges.compute_hessian_eigenvalues(img, sigma)
    sh = img.shape
    v = np.zeros(sh)
    for r in range(sh[0]):
        for c in range(sh[1]):
            for h in range(sh[2]):
                arr = (Hl[0][r,c,h], Hl[1][r,c,h], Hl[2][r,c,h])

                l1,l2,l3 = sorted(arr, key=abs)
                
                if l2 >= 0 or l3 >=0:
                    v[r,c,h] = 0
                else:
                    Ra = np.abs(l2/l3)
                    Rb = np.abs(l1/np.sqrt(np.abs(l2*l3)))
                    S = np.sqrt(l1**2 + l2**2 + l3**2)
                    v[r,c, h] =  (1 - np.exp(-Ra**2/(2*alpha**2)))*np.exp(-Rb**2/(2*beta**2))*(1 - np.exp(-S**2/(2*cc**2)))
    return v


def multiscale_vesselness(img, sigma_start, sigma_stop, nlevels=50, reduce_fn=np.max):
    return reduce_fn([vesselness(img, sigma)*sigma**2 for sigma in np.linspace(sigma_start,sigma_stop, nlevels)],0)

```

```{python}
def multiscale_sigma(img, sigma_start, sigma_stop, nlevels=50):
    sout = np.zeros(img.shape)
    hout = np.zeros(img.shape)
    for sigma in tqdm(np.linspace(sigma_start, sigma_stop, nlevels)):
        hcurr = vesselness(img, sigma)*sigma**2
        hout = np.where(hout > hcurr, hout, hcurr)
        sout = np.where(hout > hcurr, sout, sigma)
    return hout, sout
```

```{python}
h, s = multiscale_sigma(final_image, 0.5, 4)
```

```{python}
hs = napari.view_image(s)
hs.add_image(h)
```

```{python}
s[32]
```
