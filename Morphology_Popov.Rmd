---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.1
  kernelspec:
    display_name: venv
    language: python
    name: venv
---

```{python}
import os
import sys
import itertools as itt

# File reading
from pathlib import Path
import czifile as czi
import tifffile as tiff

# Image preprocessing
import cv2
from skimage.filters import threshold_li, threshold_minimum, threshold_triangle
from skimage.morphology import remove_small_objects


# Calculations
from scipy import ndimage as ndi
import numpy as np

# Analysis
import astrobject as ao
import ccdb
import astromorpho as astro

# Viewing
import napari
import matplotlib.pyplot as plt
# %matplotlib inline

# Beauty
from tqdm.auto import tqdm
```

# Параметры для запуска

```{python}
if os.path.exists('/home/incredible/astro-morpho'):
    data_dir = '/home/incredible/astro-morpho/data/HT_Tumor_12vs34 for Tatiana/'
else:
    print("Dont know where to look for the data")

output_dir = '../output/'

filename = 'T1.czi'

use_clahe = True
sigmas = 2**np.arange(0, 3, 0.5)
alpha = 0.5 # relative weight of coside distance between Hessian vector and linkage vector
beta = 0.0  # weight of Euclidean distance between the nodes 
offset=1

VERBOSE = True

# Set false to start from console
HANDY = True

# Set true to save output
OUT = False
```

# Считывание изображения

```{python}
if HANDY:
    VERBOSE = True
```

```{python}
datapath = Path(data_dir).joinpath(filename)
# datapath = Path(data_dir).joinpath(filename)
datapath
```

```{python}
tifname = str(datapath)[:-3] + 'tif' 

czi.czi2tif(datapath, tiffile=tifname)
stack = tiff.imread(tifname)[2]
```

```{python}
if VERBOSE:
    w = napari.view_image(stack)
```

# Удаление пипетки

```{python}
import pipette_segmentation as ps
```

```{python}
simple_mask = ps.make_simple_mask(stack)
sato_mask = ps.make_sato_mask(stack)
masks3 = ps.combine_masks(stack, simple_mask, sato_mask)

vx = masks3.sum(axis=(1,2))
vx_sato = ps.st_roll(sato_mask).sum(axis=(1,2))

try:
    kink = ps.find_kink(vx)
except :
    #print(E)
    kink = len(vx)

masks3a = masks3.copy()
masks3a[kink:]=0
masks3a = ucats.masks.largest_region(masks3a)

masks3_final = masks3a if use_kink else masks3
masks3_final = np.moveaxis(masks3_final,0,2)

show_stack = (stack*(~(ndi.binary_dilation(masks3_final,iterations=3)))).astype(float64)
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```
